"use strict";
(self["webpackChunkwasm_terminal"] = self["webpackChunkwasm_terminal"] || []).push([["src_styles_css-src_wasm-terminal_ts"],{

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles.css":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\nbody {\n    max-width: 800px;\n    margin: 0 auto\n}\n\n#code {\n    width: 100%;\n    height: 180px;\n}\n\n.button-container {\n    display: flex;\n    justify-content: end;\n    height: 50px;\n    align-items: center;\n    gap: 10px;\n}\n\nbutton {\n    padding: 6px 18px;\n\n}", "",{"version":3,"sources":["webpack://./src/styles.css"],"names":[],"mappings":";AACA;IACI,gBAAgB;IAChB;AACJ;;AAEA;IACI,WAAW;IACX,aAAa;AACjB;;AAEA;IACI,aAAa;IACb,oBAAoB;IACpB,YAAY;IACZ,mBAAmB;IACnB,SAAS;AACb;;AAEA;IACI,iBAAiB;;AAErB","sourcesContent":["\nbody {\n    max-width: 800px;\n    margin: 0 auto\n}\n\n#code {\n    width: 100%;\n    height: 180px;\n}\n\n.button-container {\n    display: flex;\n    justify-content: end;\n    height: 50px;\n    align-items: center;\n    gap: 10px;\n}\n\nbutton {\n    padding: 6px 18px;\n\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./src/styles.css":
/*!************************!*\
  !*** ./src/styles.css ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./styles.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_styles_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/wasm-shell/shell-utils.ts":
/*!***************************************!*\
  !*** ./src/wasm-shell/shell-utils.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasTrailingWhitespace = exports.isIncompleteInput = exports.closestRightBoundary = exports.closestLeftBoundary = exports.wordBoundaries = void 0;
/**
 * Detects all the word boundaries on the given input
 */
function wordBoundaries(input, leftSide) {
    if (leftSide === void 0) { leftSide = true; }
    var match;
    var words = [];
    var rx = /\w+/g;
    match = rx.exec(input);
    while (match) {
        if (leftSide) {
            words.push(match.index);
        }
        else {
            words.push(match.index + match[0].length);
        }
        match = rx.exec(input);
    }
    return words;
}
exports.wordBoundaries = wordBoundaries;
/**
 * The closest left (or right) word boundary of the given input at the
 * given offset.
 */
function closestLeftBoundary(input, offset) {
    var found = wordBoundaries(input, true)
        .reverse()
        .find(function (x) { return x < offset; });
    return found === undefined ? 0 : found;
}
exports.closestLeftBoundary = closestLeftBoundary;
function closestRightBoundary(input, offset) {
    var found = wordBoundaries(input, false).find(function (x) { return x > offset; });
    return found === undefined ? input.length : found;
}
exports.closestRightBoundary = closestRightBoundary;
/**
 * Checks if there is an incomplete input
 *
 * An incomplete input is considered:
 * - An input that contains unterminated single quotes
 * - An input that contains unterminated double quotes
 * - An input that ends with "\"
 * - An input that has an incomplete boolean shell expression (&& and ||)
 * - An incomplete pipe expression (|)
 */
function isIncompleteInput(input) {
    // Empty input is not incomplete
    if (input.trim() === "") {
        return false;
    }
    // Check for dangling single-quote strings
    if ((input.match(/'/g) || []).length % 2 !== 0) {
        return true;
    }
    // Check for dangling double-quote strings
    if ((input.match(/"/g) || []).length % 2 !== 0) {
        return true;
    }
    // Check for dangling boolean or pipe operations
    if (input.split(/(\|\||\||&&)/g).pop().trim() === "") {
        return true;
    }
    // Check for tailing slash
    if (input.endsWith("\\") && !input.endsWith("\\\\")) {
        return true;
    }
    return false;
}
exports.isIncompleteInput = isIncompleteInput;
/**
 * Returns true if the expression ends on a tailing whitespace
 */
function hasTrailingWhitespace(input) {
    return input.match(/[^\\][ \t]$/m) !== null;
}
exports.hasTrailingWhitespace = hasTrailingWhitespace;


/***/ }),

/***/ "./src/wasm-shell/wasm-shell.ts":
/*!**************************************!*\
  !*** ./src/wasm-shell/wasm-shell.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var shell_utils_1 = __webpack_require__(/*! ./shell-utils */ "./src/wasm-shell/shell-utils.ts");
/**
 * A shell is the primary interface that is used to start other programs.
 * It's purpose to handle:
 * - Job control (control of child processes),
 * - Control Sequences (CTRL+C to kill the foreground process)
 * - Line editing and history
 * - Output text to the tty -> terminal
 * - Interpret text within the tty to launch processes and interpret programs
 */
var WasmShell = /** @class */ (function () {
    function WasmShell(wasmTerminalConfig, wasmTty, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        /**
         * Move cursor at given direction
         */
        this.handleCursorMove = function (dir) {
            if (dir > 0) {
                var num = Math.min(dir, _this.wasmTty.getInput().length - _this.wasmTty.getCursor());
                _this.wasmTty.setCursorDirectly(_this.wasmTty.getCursor() + num);
            }
            else if (dir < 0) {
                var num = Math.max(dir, -_this.wasmTty.getCursor());
                _this.wasmTty.setCursorDirectly(_this.wasmTty.getCursor() + num);
            }
        };
        /**
         * Erase a character at cursor location
         */
        this.handleCursorErase = function (backspace) {
            if (backspace) {
                if (_this.wasmTty.getCursor() <= 0)
                    return;
                var newInput = _this.wasmTty.getInput().substr(0, _this.wasmTty.getCursor() - 1) +
                    _this.wasmTty.getInput().substr(_this.wasmTty.getCursor());
                _this.wasmTty.clearInput();
                _this.wasmTty.setCursorDirectly(_this.wasmTty.getCursor() - 1);
                _this.wasmTty.setInput(newInput, true);
            }
            else {
                var newInput = _this.wasmTty.getInput().substr(0, _this.wasmTty.getCursor()) +
                    _this.wasmTty.getInput().substr(_this.wasmTty.getCursor() + 1);
                _this.wasmTty.setInput(newInput);
            }
        };
        /**
         * Insert character at cursor location
         */
        this.handleCursorInsert = function (data) {
            var newInput = _this.wasmTty.getInput().substr(0, _this.wasmTty.getCursor()) +
                data +
                _this.wasmTty.getInput().substr(_this.wasmTty.getCursor());
            _this.wasmTty.setCursorDirectly(_this.wasmTty.getCursor() + data.length);
            _this.wasmTty.setInput(newInput);
        };
        /**
         * Handle input completion
         */
        this.handleReadComplete = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this._activePrompt && this._activePrompt.resolve) {
                    // TODO: Need to do stuff with this in a promise
                    this._activePrompt.resolve(this.wasmTty.getInput() + '\n');
                    this._activePrompt = undefined;
                }
                this.wasmTty.print('\r\n');
                this._active = false;
                return [2 /*return*/];
            });
        }); };
        /**
         * Handle terminal -> tty input
         */
        this.handleTermData = function (data) {
            // Only Allow CTRL+C Through
            if (!_this._active && data !== "\x03") {
                return;
            }
            if (_this.wasmTty.getFirstInit() && _this._activePrompt) {
                var line = _this.wasmTty
                    .getBuffer()
                    .getLine(_this.wasmTty.getBuffer().cursorY + _this.wasmTty.getBuffer().baseY);
                var promptRead = line.translateToString(false, 0, _this.wasmTty.getBuffer().cursorX);
                _this._activePrompt.promptPrefix = promptRead;
                _this.wasmTty.setPromptPrefix(promptRead);
                _this.wasmTty.setFirstInit(false);
            }
            // If we have an active character prompt, satisfy it in priority
            if (_this._activeCharPrompt && _this._activeCharPrompt.resolve) {
                _this._activeCharPrompt.resolve(data);
                _this._activeCharPrompt = undefined;
                // this.wasmTty.print("\r\n");
                return;
            }
            // If this looks like a pasted input, expand it
            if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {
                var normData = data.replace(/[\r\n]+/g, "\r");
                Array.from(normData).forEach(function (c) { return _this.handleData(c); });
            }
            else {
                _this.handleData(data);
            }
        };
        /**
         * Handle a single piece of information from the terminal -> tty.
         */
        this.handleData = function (data) {
            // Only Allow CTRL+C Through
            if (!_this._active && data !== "\x03") {
                return;
            }
            var ord = data.charCodeAt(0);
            var ofs;
            // Handle ANSI escape sequences
            if (ord === 0x1b) {
                switch (data.substr(1)) {
                    case "[A": // Up arrow
                        break;
                    case "[B": // Down arrow
                        break;
                    case "[D": // Left Arrow
                        _this.handleCursorMove(-1);
                        break;
                    case "[C": // Right Arrow
                        _this.handleCursorMove(1);
                        break;
                    case "[3~": // Delete
                        _this.handleCursorErase(false);
                        break;
                    case "[F": // End
                        _this.wasmTty.setCursor(_this.wasmTty.getInput().length);
                        break;
                    case "[H": // Home
                        _this.wasmTty.setCursor(0);
                        break;
                    // case "b": // ALT + a
                    case "b": // ALT + LEFT
                        ofs = (0, shell_utils_1.closestLeftBoundary)(_this.wasmTty.getInput(), _this.wasmTty.getCursor());
                        if (ofs)
                            _this.wasmTty.setCursor(ofs);
                        break;
                    case "f": // ALT + RIGHT
                        ofs = (0, shell_utils_1.closestRightBoundary)(_this.wasmTty.getInput(), _this.wasmTty.getCursor());
                        if (ofs)
                            _this.wasmTty.setCursor(ofs);
                        break;
                    case "\x7F": // CTRL + BACKSPACE
                        ofs = (0, shell_utils_1.closestLeftBoundary)(_this.wasmTty.getInput(), _this.wasmTty.getCursor());
                        if (ofs) {
                            _this.wasmTty.setInput(_this.wasmTty.getInput().substr(0, ofs) +
                                _this.wasmTty.getInput().substr(_this.wasmTty.getCursor()));
                            _this.wasmTty.setCursor(ofs);
                        }
                        break;
                }
                // Handle special characters
            }
            else if (ord < 32 || ord === 0x7f) {
                switch (data) {
                    case "\r": // ENTER
                    case "\x0a": // CTRL+J
                    case "\x0d": // CTRL+M
                        _this.handleReadComplete();
                        break;
                    case "\x7F": // BACKSPACE
                    case "\x08": // CTRL+H
                    case "\x04": // CTRL+D
                        _this.handleCursorErase(true);
                        break;
                    case "\t": // TAB
                        _this.handleCursorInsert("    ");
                        break;
                    case "\x01": // CTRL+A
                        _this.wasmTty.setCursor(0);
                        break;
                    case "\x02": // CTRL+B
                        _this.handleCursorMove(-1);
                        break;
                    case "\x03": // CTRL+C
                    case "\x1a": // CTRL+Z
                        var currentInput = _this.wasmTty.getInput();
                        _this.wasmTty.setCursor(currentInput.length);
                        _this.wasmTty.setInput("");
                        _this.wasmTty.setCursorDirectly(0);
                        _this.wasmTty.print(currentInput + "^C\r\n");
                        // // Kill the command
                        // if (this.commandRunner) {
                        //   this.commandRunner.kill();
                        //   this.commandRunner = undefined;
                        // }
                        // If we are prompting, then we want to cancel the current read
                        _this.resolveActiveRead();
                        break;
                    case "\x05": // CTRL+E
                        _this.wasmTty.setCursor(_this.wasmTty.getInput().length);
                        break;
                    case "\x06": // CTRL+F
                        _this.handleCursorMove(1);
                        break;
                    case "\x07": // CTRL+G
                        _this.wasmTty.setInput("");
                        break;
                    case "\x0b": // CTRL+K
                        _this.wasmTty.setInput(_this.wasmTty.getInput().substring(0, _this.wasmTty.getCursor()));
                        _this.wasmTty.setCursor(_this.wasmTty.getInput().length);
                        break;
                    case "\x0c": // CTRL+L
                        _this.wasmTty.clearTty();
                        _this.wasmTty.print("$ ".concat(_this.wasmTty.getInput()));
                        break;
                    case "\x0e": // CTRL+N
                        break;
                    case "\x10": // CTRL+P
                        break;
                    case "\x15": // CTRL+U
                        _this.wasmTty.setInput(_this.wasmTty.getInput().substring(_this.wasmTty.getCursor()));
                        _this.wasmTty.setCursor(0);
                        break;
                }
                // Handle visible characters
            }
            else {
                _this.handleCursorInsert(data);
            }
        };
        var optionValues = __assign({ historySize: 10, maxAutocompleteEntries: 100, disablePrompt: false }, options);
        this.wasmTerminalConfig = wasmTerminalConfig;
        this.wasmTty = wasmTty;
        this.maxAutocompleteEntries = optionValues.maxAutocompleteEntries;
        this.disablePrompt = optionValues.disablePrompt;
        this._active = false;
    }
    WasmShell.prototype.prompt = function () {
        return __awaiter(this, void 0, void 0, function () {
            var line, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // If we are already prompting, do nothing...
                        if (this._activePrompt || this.disablePrompt) {
                            return [2 /*return*/, ''];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        this._activePrompt = this.wasmTty.read("");
                        this._active = true;
                        return [4 /*yield*/, this._activePrompt.promise];
                    case 2:
                        line = _a.sent();
                        return [2 /*return*/, line];
                    case 3:
                        e_1 = _a.sent();
                        this.wasmTty.println("".concat(e_1));
                        // tslint:disable-next-line
                        this.prompt();
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    WasmShell.prototype.isPrompting = function () {
        return this._active;
    };
    /**
     * This function completes the current input, calls the given callback
     * and then re-displays the prompt.
     */
    WasmShell.prototype.printAndRestartPrompt = function (callback) {
        var _this = this;
        // Complete input
        this.wasmTty.setCursor(this.wasmTty.getInput().length);
        this.wasmTty.print("\r\n");
        // Prepare a function that will resume prompt
        var resume = function () {
            _this.wasmTty.setCursor(_this.wasmTty.getCursor());
            _this.wasmTty.setInput(_this.wasmTty.getInput());
        };
        // Call the given callback to echo something, and if there is a promise
        // returned, wait for the resolution before resuming prompt.
        var ret = callback();
        if (ret) {
            // tslint:disable-next-line
            ret.then(resume);
        }
        else {
            resume();
        }
    };
    /**
     * Resolve a pending read operation
     * (Will resolve an empty string)
     */
    WasmShell.prototype.resolveActiveRead = function () {
        // Abort the read if we were reading
        if (this._activePrompt && this._activePrompt.resolve) {
            this._activePrompt.resolve("");
            this._activePrompt = undefined;
        }
        if (this._activeCharPrompt && this._activeCharPrompt.resolve) {
            this._activeCharPrompt.resolve("");
            this._activeCharPrompt = undefined;
        }
        this._active = false;
    };
    /**
     * Abort a pending read operation
     */
    WasmShell.prototype.rejectActiveRead = function (reason) {
        if (reason === void 0) { reason = "aborted"; }
        if (this._activePrompt || this._activeCharPrompt) {
            this.wasmTty.print("\r\n");
        }
        if (this._activePrompt && this._activePrompt.reject) {
            this._activePrompt.reject(new Error(reason));
            this._activePrompt = undefined;
        }
        if (this._activeCharPrompt && this._activeCharPrompt.reject) {
            this._activeCharPrompt.reject(new Error(reason));
            this._activeCharPrompt = undefined;
        }
        this._active = false;
    };
    return WasmShell;
}());
exports["default"] = WasmShell;


/***/ }),

/***/ "./src/wasm-terminal-config.ts":
/*!*************************************!*\
  !*** ./src/wasm-terminal-config.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {


// The configuration options passed when creating the Wasm terminal
Object.defineProperty(exports, "__esModule", ({ value: true }));
var WasmTerminalConfig = /** @class */ (function () {
    function WasmTerminalConfig(_a) {
        var fetchCommand = _a.fetchCommand, processWorkerUrl = _a.processWorkerUrl;
        this.fetchCommand = fetchCommand;
        this.processWorkerUrl = processWorkerUrl;
    }
    return WasmTerminalConfig;
}());
exports["default"] = WasmTerminalConfig;


/***/ }),

/***/ "./src/wasm-terminal.ts":
/*!******************************!*\
  !*** ./src/wasm-terminal.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// The Wasm Terminal
// @ts-ignore
var xterm_1 = __importDefault(__webpack_require__(/*! xterm */ "./node_modules/xterm/lib/xterm.js"));
var xtermDefault = __importStar(__webpack_require__(/*! xterm */ "./node_modules/xterm/lib/xterm.js"));
var Terminal = xtermDefault.Terminal || xterm_1.default.Terminal;
var xterm_addon_fit_1 = __webpack_require__(/*! xterm-addon-fit */ "./node_modules/xterm-addon-fit/lib/xterm-addon-fit.js");
var xterm_addon_web_links_1 = __webpack_require__(/*! xterm-addon-web-links */ "./node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js");
var wasm_terminal_config_1 = __importDefault(__webpack_require__(/*! ./wasm-terminal-config */ "./src/wasm-terminal-config.ts"));
var wasm_tty_1 = __importDefault(__webpack_require__(/*! ./wasm-tty/wasm-tty */ "./src/wasm-tty/wasm-tty.ts"));
var wasm_shell_1 = __importDefault(__webpack_require__(/*! ./wasm-shell/wasm-shell */ "./src/wasm-shell/wasm-shell.ts"));
var MOBILE_KEYBOARD_EVENTS = ["click", "tap"];
var WasmTerminal = /** @class */ (function () {
    function WasmTerminal(config) {
        var _this = this;
        /**
         * Handle terminal resize
         *
         * This function clears the prompt using the previous configuration,
         * updates the cached terminal size information and then re-renders the
         * input. This leads (most of the times) into a better formatted input.
         */
        this.handleTermResize = function (data) {
            var rows = data.rows, cols = data.cols;
            _this.wasmTty.clearInput();
            _this.wasmTty.setTermSize(cols, rows);
            _this.wasmTty.setInput(_this.wasmTty.getInput(), true);
        };
        this.wasmTerminalConfig = new wasm_terminal_config_1.default(config);
        // Create our xterm element
        this.xterm = new Terminal({ scrollback: 10000, fontSize: 14, theme: { background: '#1a1c1f' }, cols: 100 });
        // tslint:disable-next-line
        // this.pasteEvent = this.xterm.on("paste", this.onPaste);
        // tslint:disable-next-line
        this.resizeEvent = this.xterm.onResize(this.handleTermResize);
        this.xterm.onKey(function (keyEvent) {
            // Fix for iOS Keyboard Jumping on space
            if (keyEvent.key === " ") {
                keyEvent.domEvent.preventDefault();
            }
        });
        // Set up our container
        this.container = undefined;
        // Load our addons
        this.webLinksAddon = new xterm_addon_web_links_1.WebLinksAddon();
        this.fitAddon = new xterm_addon_fit_1.FitAddon();
        this.xterm.loadAddon(this.fitAddon);
        this.xterm.loadAddon(this.webLinksAddon);
        this.wasmTerminalConfig = new wasm_terminal_config_1.default(config);
        // Create our Shell and tty
        this.wasmTty = new wasm_tty_1.default(this.xterm);
        this.wasmShell = new wasm_shell_1.default(this.wasmTerminalConfig, this.wasmTty, {
            disablePrompt: false,
        });
        // tslint:disable-next-line
        this.dataEvent = this.xterm.onData(this.wasmShell.handleTermData);
        this.isOpen = false;
        this.pendingPrintOnOpen = "";
    }
    WasmTerminal.prototype.open = function (container) {
        var _this = this;
        // Remove any current event listeners
        var focusHandler = this.focus.bind(this);
        if (this.container !== undefined) {
            MOBILE_KEYBOARD_EVENTS.forEach(function (eventName) {
                _this.container.removeEventListener(eventName, focusHandler);
            });
        }
        this.container = container;
        this.xterm.open(container);
        this.isOpen = true;
        setTimeout(function () {
            // Fix for Mobile Browsers and their virtual keyboards
            if (_this.container !== undefined) {
                MOBILE_KEYBOARD_EVENTS.forEach(function (eventName) {
                    _this.container.addEventListener(eventName, focusHandler);
                });
            }
            if (_this.pendingPrintOnOpen) {
                _this.wasmTty.print(_this.pendingPrintOnOpen + "\n");
                _this.pendingPrintOnOpen = "";
            }
        });
    };
    WasmTerminal.prototype.fit = function () {
        this.fitAddon.fit();
    };
    WasmTerminal.prototype.clear = function () {
        this.xterm.clear();
    };
    WasmTerminal.prototype.focus = function () {
        this.xterm.focus();
    };
    WasmTerminal.prototype.print = function (message, sync) {
        var _this = this;
        // For some reason, double new lines are not respected. Thus, fixing that here
        message = message.replace(/\n\n/g, "\n \n");
        if (!this.isOpen) {
            if (this.pendingPrintOnOpen) {
                this.pendingPrintOnOpen += message;
            }
            else {
                this.pendingPrintOnOpen = message;
            }
            return;
        }
        if (this.wasmShell.isPrompting()) {
            // Cancel the current prompt and restart
            this.wasmShell.printAndRestartPrompt(function () {
                _this.wasmTty.print(message + "\n", sync);
                return undefined;
            });
            return;
        }
        this.wasmTty.print(message, sync);
    };
    WasmTerminal.prototype.kill = function () {
        // return this.wasmShell.commandRunner?.kill();
    };
    WasmTerminal.prototype.destroy = function () {
        this.xterm.dispose();
        delete this.xterm;
    };
    WasmTerminal.prototype.onPaste = function (data) {
        this.wasmTty.print(data);
    };
    return WasmTerminal;
}());
exports["default"] = WasmTerminal;


/***/ }),

/***/ "./src/wasm-tty/tty-utils.ts":
/*!***********************************!*\
  !*** ./src/wasm-tty/tty-utils.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.countLines = exports.offsetToColRow = void 0;
/**
 * Convert offset at the given input to col/row location
 *
 * This function is not optimized and practically emulates via brute-force
 * the navigation on the terminal, wrapping when they reach the column width.
 */
function offsetToColRow(input, offset, maxCols) {
    var row = 0;
    var col = 0;
    for (var i = 0; i < offset; ++i) {
        var chr = input.charAt(i);
        if (chr === "\n") {
            col = 0;
            row += 1;
        }
        else {
            col += 1;
            if (col > maxCols) {
                col = 0;
                row += 1;
            }
        }
    }
    return { row: row, col: col };
}
exports.offsetToColRow = offsetToColRow;
/**
 * Counts the lines in the given input
 */
function countLines(input, maxCols) {
    return offsetToColRow(input, input.length, maxCols).row + 1;
}
exports.countLines = countLines;


/***/ }),

/***/ "./src/wasm-tty/wasm-tty.ts":
/*!**********************************!*\
  !*** ./src/wasm-tty/wasm-tty.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tty_utils_1 = __webpack_require__(/*! ./tty-utils */ "./src/wasm-tty/tty-utils.ts");
/**
 * A tty is a particular device file, that sits between the shell and the terminal.
 * It acts an an interface for the shell and terminal to read/write from,
 * and communicate with one another
 */
// type AutoCompleteHandler = (index: number, tokens: string[]) => string[];
var WasmTTY = /** @class */ (function () {
    function WasmTTY(xterm) {
        this._firstInit = true;
        this.xterm = xterm;
        this._termSize = {
            cols: this.xterm.cols,
            rows: this.xterm.rows,
        };
        this._promptPrefix = "";
        this._continuationPromptPrefix = "";
        this._input = "";
        this._cursor = 0;
    }
    /**
     * Function to return a deconstructed readPromise
     */
    WasmTTY.prototype._getAsyncRead = function () {
        var _this = this;
        var readResolve;
        var readReject;
        var readPromise = new Promise(function (resolve, reject) {
            readResolve = function (response) {
                _this._promptPrefix = "";
                _this._continuationPromptPrefix = "";
                resolve(response);
            };
            readReject = reject;
        });
        return {
            promise: readPromise,
            resolve: readResolve,
            reject: readReject,
        };
    };
    /**
     * Return a promise that will resolve when the user has completed
     * typing a single line
     */
    WasmTTY.prototype.read = function (promptPrefix, continuationPromptPrefix) {
        if (continuationPromptPrefix === void 0) { continuationPromptPrefix = ""; }
        if (promptPrefix.length > 0) {
            this.print(promptPrefix);
        }
        this._firstInit = true;
        this._promptPrefix = promptPrefix;
        this._continuationPromptPrefix = continuationPromptPrefix;
        this._input = "";
        this._cursor = 0;
        return __assign({ promptPrefix: promptPrefix, continuationPromptPrefix: continuationPromptPrefix }, this._getAsyncRead());
    };
    /**
     * Return a promise that will be resolved when the user types a single
     * character.
     *
     * This can be active in addition to `.read()` and will be resolved in
     * priority before it.
     */
    WasmTTY.prototype.readChar = function (promptPrefix) {
        if (promptPrefix.length > 0) {
            this.print(promptPrefix);
        }
        return __assign({ promptPrefix: promptPrefix }, this._getAsyncRead());
    };
    /**
     * Prints a message and changes line
     */
    WasmTTY.prototype.println = function (message) {
        this.print(message + "\n");
    };
    /**
     * Prints a message and properly handles new-lines
     */
    WasmTTY.prototype.print = function (message, sync) {
        var _this = this;
        var normInput = message.replace(/[\r\n]+/g, "\n").replace(/\n/g, "\r\n");
        if (sync) {
            // We write it synchronously via hacking a bit on xterm
            //@ts-ignore
            this.xterm._core.writeSync(normInput);
            //@ts-ignore
            this.xterm._core._renderService._renderer._runOperation(function (renderer) {
                return renderer.onGridChanged(0, _this.xterm.rows - 1);
            });
        }
        else {
            //@ts-ignore
            this.xterm.write(normInput);
        }
    };
    /**
     * Prints a list of items using a wide-format
     */
    WasmTTY.prototype.printWide = function (items, padding) {
        if (padding === void 0) { padding = 2; }
        if (items.length === 0)
            return this.println("");
        // Compute item sizes and matrix row/cols
        var itemWidth = items.reduce(function (width, item) { return Math.max(width, item.length); }, 0) + padding;
        var wideCols = Math.floor(this._termSize.cols / itemWidth);
        var wideRows = Math.ceil(items.length / wideCols);
        // Print matrix
        var i = 0;
        for (var row = 0; row < wideRows; ++row) {
            var rowStr = "";
            // Prepare columns
            for (var col = 0; col < wideCols; ++col) {
                if (i < items.length) {
                    var item = items[i++];
                    item += " ".repeat(itemWidth - item.length);
                    rowStr += item;
                }
            }
            this.println(rowStr);
        }
    };
    /**
     * Prints a status message on the current line. Meant to be used with clearStatus()
     */
    WasmTTY.prototype.printStatus = function (message, sync) {
        // Save the cursor position
        this.print("\u001b[s", sync);
        this.print(message, sync);
    };
    /**
     * Clears the current status on the line, meant to be run after printStatus
     */
    WasmTTY.prototype.clearStatus = function (sync) {
        // Restore the cursor position
        this.print("\u001b[u", sync);
        // Clear from cursor to end of screen
        this.print("\u001b[1000D", sync);
        this.print("\u001b[0J", sync);
    };
    /**
     * Apply prompts to the given input
     */
    WasmTTY.prototype.applyPrompts = function (input) {
        return (this._promptPrefix +
            input.replace(/\n/g, "\n" + this._continuationPromptPrefix));
    };
    /**
     * Advances the `offset` as required in order to accompany the prompt
     * additions to the input.
     */
    WasmTTY.prototype.applyPromptOffset = function (input, offset) {
        var newInput = this.applyPrompts(input.substr(0, offset));
        return newInput.length;
    };
    /**
     * Clears the current prompt
     *
     * This function will erase all the lines that display the current prompt
     * and move the cursor in the beginning of the first line of the prompt.
     */
    WasmTTY.prototype.clearInput = function () {
        var currentPrompt = this.applyPrompts(this._input);
        // Get the overall number of lines to clear
        var allRows = (0, tty_utils_1.countLines)(currentPrompt, this._termSize.cols);
        // Get the line we are currently in
        var promptCursor = this.applyPromptOffset(this._input, this._cursor);
        var row = (0, tty_utils_1.offsetToColRow)(currentPrompt, promptCursor, this._termSize.cols).row;
        // First move on the last line
        var moveRows = allRows - row - 1;
        for (var i = 0; i < moveRows; ++i)
            this.xterm.write("\x1B[E");
        // Clear current input line(s)
        this.xterm.write("\r\x1B[K");
        for (var i = 1; i < allRows; ++i)
            this.xterm.write("\x1B[F\x1B[K");
    };
    /**
     * Clears the entire Tty
     *
     * This function will erase all the lines that display on the tty,
     * and move the cursor in the beginning of the first line of the prompt.
     */
    WasmTTY.prototype.clearTty = function () {
        // Clear the screen
        this.xterm.write("\u001b[2J");
        // Set the cursor to 0, 0
        this.xterm.write("\u001b[0;0H");
        this._cursor = 0;
    };
    /**
     * Function to return if it is the initial read
     */
    WasmTTY.prototype.getFirstInit = function () {
        return this._firstInit;
    };
    /**
     * Function to get the current Prompt prefix
     */
    WasmTTY.prototype.getPromptPrefix = function () {
        return this._promptPrefix;
    };
    /**
     * Function to get the current Continuation Prompt prefix
     */
    WasmTTY.prototype.getContinuationPromptPrefix = function () {
        return this._continuationPromptPrefix;
    };
    /**
     * Function to get the terminal size
     */
    WasmTTY.prototype.getTermSize = function () {
        return this._termSize;
    };
    /**
     * Function to get the current input in the line
     */
    WasmTTY.prototype.getInput = function () {
        return this._input;
    };
    /**
     * Function to get the current cursor
     */
    WasmTTY.prototype.getCursor = function () {
        return this._cursor;
    };
    /**
     * Function to get the size (columns and rows)
     */
    WasmTTY.prototype.getSize = function () {
        return this._termSize;
    };
    /**
     * Function to return the terminal buffer
     */
    WasmTTY.prototype.getBuffer = function () {
        return this.xterm.buffer.active;
    };
    /**
     * Replace input with the new input given
     *
     * This function clears all the lines that the current input occupies and
     * then replaces them with the new input.
     */
    WasmTTY.prototype.setInput = function (newInput, shouldNotClearInput) {
        if (shouldNotClearInput === void 0) { shouldNotClearInput = false; }
        // Doing the programming anitpattern here,
        // because defaulting to true is the opposite of what
        // not passing a param means in JS
        if (!shouldNotClearInput) {
            this.clearInput();
        }
        // Write the new input lines, including the current prompt
        var newPrompt = this.applyPrompts(newInput);
        this.print(newPrompt);
        // Trim cursor overflow
        if (this._cursor > newInput.length) {
            this._cursor = newInput.length;
        }
        // Move the cursor to the appropriate row/col
        var newCursor = this.applyPromptOffset(newInput, this._cursor);
        var newLines = (0, tty_utils_1.countLines)(newPrompt, this._termSize.cols);
        var _a = (0, tty_utils_1.offsetToColRow)(newPrompt, newCursor, this._termSize.cols), col = _a.col, row = _a.row;
        var moveUpRows = newLines - row - 1;
        this.xterm.write("\r");
        for (var i = 0; i < moveUpRows; ++i)
            this.xterm.write("\x1B[F");
        for (var i = 0; i < col; ++i)
            this.xterm.write("\x1B[C");
        // Replace input
        this._input = newInput;
    };
    /**
     * Set the new cursor position, as an offset on the input string
     *
     * This function:
     * - Calculates the previous and current
     */
    WasmTTY.prototype.setCursor = function (newCursor) {
        if (newCursor < 0)
            newCursor = 0;
        if (newCursor > this._input.length)
            newCursor = this._input.length;
        this._writeCursorPosition(newCursor);
    };
    /**
     * Sets the direct cursor value. Should only be used in keystroke contexts
     */
    WasmTTY.prototype.setCursorDirectly = function (newCursor) {
        this._writeCursorPosition(newCursor);
    };
    WasmTTY.prototype._writeCursorPosition = function (newCursor) {
        // Apply prompt formatting to get the visual status of the display
        var inputWithPrompt = this.applyPrompts(this._input);
        // Estimate previous cursor position
        var prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);
        var _a = (0, tty_utils_1.offsetToColRow)(inputWithPrompt, prevPromptOffset, this._termSize.cols), prevCol = _a.col, prevRow = _a.row;
        // Estimate next cursor position
        var newPromptOffset = this.applyPromptOffset(this._input, newCursor);
        var _b = (0, tty_utils_1.offsetToColRow)(inputWithPrompt, newPromptOffset, this._termSize.cols), newCol = _b.col, newRow = _b.row;
        // Adjust vertically
        if (newRow > prevRow) {
            for (var i = prevRow; i < newRow; ++i)
                this.xterm.write("\x1B[B");
        }
        else {
            for (var i = newRow; i < prevRow; ++i)
                this.xterm.write("\x1B[A");
        }
        // Adjust horizontally
        if (newCol > prevCol) {
            for (var i = prevCol; i < newCol; ++i)
                this.xterm.write("\x1B[C");
        }
        else {
            for (var i = newCol; i < prevCol; ++i)
                this.xterm.write("\x1B[D");
        }
        // Set new offset
        this._cursor = newCursor;
    };
    WasmTTY.prototype.setTermSize = function (cols, rows) {
        this._termSize = { cols: cols, rows: rows };
    };
    WasmTTY.prototype.setFirstInit = function (value) {
        this._firstInit = value;
    };
    WasmTTY.prototype.setPromptPrefix = function (value) {
        this._promptPrefix = value;
    };
    WasmTTY.prototype.setContinuationPromptPrefix = function (value) {
        this._continuationPromptPrefix = value;
    };
    return WasmTTY;
}());
exports["default"] = WasmTTY;


/***/ })

}]);
//# sourceMappingURL=src_styles_css-src_wasm-terminal_ts-040ec87055eaf45978e0.js.map